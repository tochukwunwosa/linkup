import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { rateLimit, getClientIp } from "@/lib/rate-limit";
import { autocompleteCache } from "@/lib/places/cache";
import { fetchAutocompletePredictions } from "@/lib/places/places-service";
import type { AutocompleteApiResponse } from "@/lib/places/types";

const requestSchema = z.object({
  /** The text typed by the user — minimum 1 char (3-char guard is on the client) */
  input: z.string().min(1).max(200),
  /** UUID v4 generated by the client at the start of each typing session */
  sessionToken: z.string().uuid("sessionToken must be a valid UUID v4"),
});

export async function POST(
  req: NextRequest
): Promise<NextResponse<AutocompleteApiResponse>> {
  // ── Rate limiting: 60 requests per IP per minute ─────────────────────────
  const clientIp = getClientIp(req);
  const rl = rateLimit(`places:autocomplete:${clientIp}`, {
    maxRequests: 60,
    windowMs: 60_000,
  });

  if (!rl.success) {
    const waitSecs = Math.ceil((rl.resetTime - Date.now()) / 1_000);
    return NextResponse.json(
      { error: `Rate limit exceeded. Try again in ${waitSecs}s.` },
      {
        status: 429,
        headers: {
          "Retry-After": String(waitSecs),
          "X-RateLimit-Remaining": "0",
          "X-RateLimit-Reset": new Date(rl.resetTime).toISOString(),
        },
      }
    );
  }

  // ── Parse + validate body ─────────────────────────────────────────────────
  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400 });
  }

  const parsed = requestSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.issues[0]?.message ?? "Invalid request." },
      { status: 400 }
    );
  }

  const { input, sessionToken } = parsed.data;

  // ── Cache lookup ──────────────────────────────────────────────────────────
  // Cache is keyed by (input, sessionToken) so that:
  //   • Re-typing the same string within one session is free (cache hit).
  //   • Responses never leak between different users or sessions.
  //   • The session token is always used for both autocomplete + details,
  //     preserving correct Google session-based billing.
  const cacheKey = autocompleteCache.buildKey(input, sessionToken);
  const cached = autocompleteCache.get(cacheKey);

  if (cached) {
    return NextResponse.json({ predictions: cached, cached: true });
  }

  // ── Call Google Places API ────────────────────────────────────────────────
  try {
    const predictions = await fetchAutocompletePredictions(input, sessionToken);
    autocompleteCache.set(cacheKey, predictions);
    return NextResponse.json({ predictions, cached: false });
  } catch (err) {
    console.error("[places/autocomplete]", err);
    return NextResponse.json(
      { error: "Location search is temporarily unavailable." },
      { status: 503 }
    );
  }
}
